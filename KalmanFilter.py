# -*- coding: utf-8 -*-
"""kalmann_filter.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11JRbLEBisR2frKQ9Ox0eyJF3LbLOCPi_
"""

!pip install ultralytics
!pip install opencv-python
!pip install pytesseract

"""# une format proposée en avance"""

#son adaptation avec notre projet et son test avec yolo
import cv2
import numpy as np
from ultralytics import YOLO
from google.colab.patches import cv2_imshow  # Import spécifique pour Colab

class KalmanFilter:
    def __init__(self):
        # Initialiser le filtre de Kalman
        self.kf = cv2.KalmanFilter(4, 2)
        self.kf.measurementMatrix = np.array([[1, 0, 0, 0], [0, 1, 0, 0]], np.float32)
        self.kf.transitionMatrix = np.array([[1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0], [0, 0, 0, 1]], np.float32)
        self.kf.processNoiseCov = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], np.float32) * 0.03

    def predict(self, coordX, coordY):
        measured = np.array([[np.float32(coordX)], [np.float32(coordY)]])
        self.kf.correct(measured)
        predicted = self.kf.predict()
        return predicted[0], predicted[1]

def main():
    # Initialiser YOLO
    model = YOLO('yolov8n.pt')

    # Initialiser la capture vidéo
    cap = cv2.VideoCapture('/content/sample_data/Driving_in_Moroccan_Western_Sahara_way_to_Laayoune.mp4')  # 0 pour webcam, ou chemin vers un fichier vidéo

    # Initialiser le filtre de Kalman
    kf = KalmanFilter()

    # Couleurs pour le dessin
    colors = {
        'actual': (0, 255, 0),    # Vert pour la position réelle
        'predicted': (0, 0, 255)  # Rouge pour la prédiction
    }

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        # Détecter les véhicules avec YOLO
        results = model(frame)

        for result in results:
            boxes = result.boxes

            for box in boxes:
                # Vérifier si c'est un véhicule (class_id 2 pour 'car' dans COCO)
                if box.cls == 2:  # Modifier selon votre modèle
                    # Extraire les coordonnées
                    x1, y1, x2, y2 = box.xyxy[0]
                    confidence = box.conf[0]

                    # Calculer le centre du véhicule
                    center_x = int((x1 + x2) / 2)
                    center_y = int((y1 + y2) / 2)

                    # Obtenir la prédiction du filtre de Kalman
                    predicted_x, predicted_y = kf.predict(center_x, center_y)

                    # Dessiner la boîte de détection
                    cv2.rectangle(frame, (int(x1), int(y1)), (int(x2), int(y2)), colors['actual'], 2)

                    # Dessiner le centre actuel
                    cv2.circle(frame, (center_x, center_y), 5, colors['actual'], -1)

                    # Dessiner la position prédite
                    cv2.circle(frame, (int(predicted_x), int(predicted_y)), 5, colors['predicted'], -1)

                    # Afficher la confiance
                    cv2.putText(frame, f'Conf: {confidence:.2f}', (int(x1), int(y1)-10),
                              cv2.FONT_HERSHEY_SIMPLEX, 0.5, colors['actual'], 2)

        # Afficher le frame
        cv2_imshow( frame)

        # Sortir avec 'q'
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    # Libérer les ressources
    cap.release()
    cv2.destroyAllWindows()

if __name__ == "__main__":
    main()

# test sans yolo ett
import cv2
import numpy as np
import time
from google.colab.patches import cv2_imshow  # Import spécifique pour Colab

class KalmanFilter:
    def __init__(self):
        self.kf = cv2.KalmanFilter(4, 2)
        self.kf.measurementMatrix = np.array([[1, 0, 0, 0], [0, 1, 0, 0]], np.float32)
        self.kf.transitionMatrix = np.array([[1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0], [0, 0, 0, 1]], np.float32)
        self.kf.processNoiseCov = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], np.float32) * 0.03

    def predict(self, coordX, coordY):
        measured = np.array([[np.float32(coordX)], [np.float32(coordY)]])
        self.kf.correct(measured)
        predicted = self.kf.predict()
        return predicted[0], predicted[1]

def simulate_detection(frame_count, max_width, max_height):
    """Simule un mouvement de véhicule en diagonale avec un peu de bruit"""
    base_x = (frame_count * 2) % (max_width - 100)
    base_y = (frame_count * 1) % (max_height - 100)

    noise_x = np.random.normal(0, 5)
    noise_y = np.random.normal(0, 5)

    x1 = base_x + noise_x
    y1 = base_y + noise_y
    x2 = x1 + 100
    y2 = y1 + 50

    return np.array([x1, y1, x2, y2])

def main():
    # Paramètres de l'image
    width, height = 800, 600
    kf = KalmanFilter()

    # Simuler quelques frames
    for frame_count in range(50):  # Simulons 50 frames
        # Créer une image noire
        frame = np.zeros((height, width, 3), dtype=np.uint8)

        # Simuler une détection
        box = simulate_detection(frame_count, width, height)
        x1, y1, x2, y2 = box.astype(int)

        # Calculer le centre
        center_x = int((x1 + x2) / 2)
        center_y = int((y1 + y2) / 2)

        # Prédiction Kalman
        predicted_x, predicted_y = kf.predict(center_x, center_y)

        # Dessiner
        cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)
        cv2.circle(frame, (center_x, center_y), 5, (0, 255, 0), -1)
        cv2.circle(frame, (int(predicted_x), int(predicted_y)), 5, (0, 0, 255), -1)

        # Texte explicatif
        cv2.putText(frame, "Position actuelle (vert)", (10, 30),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
        cv2.putText(frame, "Position predite (rouge)", (10, 60),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)

        # Afficher avec cv2_imshow au lieu de cv2.imshow
        cv2_imshow(frame)

        # Clear l'output de la cellule pour la prochaine frame
        from IPython.display import clear_output
        clear_output(wait=True)

        time.sleep(0.1)  # Pause entre les frames

if __name__ == "__main__":
    main()